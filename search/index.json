[{"content":"前言 在B站冲浪时，看到这样的一个视频 o(￣▽￣)ブ： \r\r其中的BrainFuck语言引起了我的注意 (☄⊙ω⊙)☄\n下面用python实现一个解释器 ᕕ( ᐛ )ᕗ\n准备 \rBrainfuck\r Brainfuck是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于fuck在英语中是脏话，这种语言有时被称为brainf*ck或brainf**k，甚至被简称为BF\nBrainfuck由8种代码组成：\n   字符 含义     \u0026gt; 指针加一   \u0026lt; 指针减一   + 指针指向的字节的值加一   - 指针指向的字节的值减一   . 输出指针指向的单元内容（ASCⅡ码）   , 输入内容到指针指向的单元（ASCⅡ码）   [ 如果指针指向的单元值为零，向后跳转到对应的]指令的次一指令处   ] 如果指针指向的单元值不为零，向前跳转到对应的[指令的次一指令处    同样 也可以通过BrainFuck的在线可视化运行的网站来增进理解：\nBrainfuck Visualizer\n了解清楚后 开始实现\n实现 我的基本思路是 用Python列表来模拟纸带 首先来创建一个函数\ndef paper_tape_machine(code): 我们要写一个函数对八种代码进行读取并进行操作，当然这不是仅进行一次的，在while循环和递归这两种方式中我选择了前者 绝对不是因为我在尝试后发现Python有最大递归深度 如下所示\ndef paper_tape_machine(code): pointer = 0 paper_tape = [0] position = 0 while position != len(code): position += 1 分别创建纸带列表 指针 位置（执行代码的位置） 变量\n当position等于代码的长度时，即代码执行完毕，退出循环\n然后加入对代码的判断 首先是\u0026gt;和\u0026lt;\n指针移动，使其值加减1即可\n我没有提前规定纸带列表的长度 所以我在使指针右移前会判断一下是否需要增加纸带长度：\nif code[position] == \u0026#39;\u0026gt;\u0026#39;: if pointer + 2 \u0026gt; len(paper_tape): paper_tape.append(0) pointer += 1 左移时也需要进行一定的判断。当指针已经出于纸带第一位时，则无法继续往前，此时报错结束函数：\nelif code[position] == \u0026#39;\u0026lt;\u0026#39;: if pointer != 0: pointer -= 1 else: print(\u0026#39;Data overflow!\u0026#39;) return +和-只需要加减列表中单个元素的值 只需要注意其特殊规则：\n255+1=0 0-1=255\nelif code[position] == \u0026#39;+\u0026#39;: if paper_tape[pointer] != 255: paper_tape[pointer] += 1 else: paper_tape[pointer] = 0 elif code[position] == \u0026#39;-\u0026#39;: if paper_tape[pointer] != 0: paper_tape[pointer] -= 1 else: paper_tape[pointer] = 255 .和,需要将整数通过ASSII编码与字符进行转化，Python中已有函数chr() ord()能实现 直接使用即可\n需要注意的是 输入时要检测一下字符串的长度\nelif code[position] == \u0026#39;.\u0026#39;: print(chr(paper_tape[pointer]),end=\u0026#39;\u0026#39;) elif code[position] == \u0026#39;,\u0026#39;: text = input() if len(text) == 1: paper_tape[pointer] = ord(text) else: print(\u0026#39;Invalid input!\u0026#39;) return 最后两个[和]实现起来有一些困难，不仅需要找到相对的括号，还必须是对应的\n我认为可以通过创建一个变量，在寻找对应符号的循环中来记录中括号的“量”以确定中括号是否对应\n具体实现逻辑就是同类符号加1，异类符号减1\nelif code[position] == \u0026#39;[\u0026#39;: if paper_tape[pointer] == 0: position += 1 while code[position] != \u0026#39;]\u0026#39; or i != 0: if code[position] == \u0026#39;[\u0026#39;: i += 1 elif code[position] == \u0026#39;]\u0026#39;: i -= 1 if position != len(code): position += 1 else: print(\u0026#39;Syntax error! (Cannot find corresponding \u0026#34;]\u0026#34;)\u0026#39;) return elif code[position] == \u0026#39;]\u0026#39;: if paper_tape[pointer] != 0: position -= 1 while code[position] != \u0026#39;[\u0026#39; or i != 0: if code[position] == \u0026#39;[\u0026#39;: i -= 1 elif code[position] == \u0026#39;]\u0026#39;: i += 1 if position != 0: position -= 1 else: print(\u0026#39;Syntax error! (Cannot find corresponding \u0026#34;[\u0026#34;)\u0026#39;) return 对于其他的字符，我给函数增加了一个布尔参数strict\n当strict为True时，当执行代码时遇到无法识别的字符就会报错并退出函数，否则则会忽略\nelse: if strict: print(\u0026#39;Invalid code \u0026#34;\u0026#39;,code[position],\u0026#39;\u0026#34; !\u0026#39;) return 为了便于测试 我们加入模式参数mode\n当mode值为normal时，即为正常模式；当其值为debug时，则会在运行过程中将代码和纸带等参数打印出来；当值为其他时，报错并停止\nif mode == \u0026#39;debug\u0026#39;: print(paper_tape,pointer,code[position],i) elif mode != \u0026#39;normal\u0026#39;: print(\u0026#39;Invalid parameter\u0026#39;) return 在[和]中的循环中加入\nif mode == \u0026#39;debug\u0026#39;: print(position,pointer,code[position],i) 最后的结果是这样的\ndef paper_tape_machine(code,mode,strict): pointer = 0 paper_tape = [0] position = 0 i = 0 while position != len(code): if code[position] == \u0026#39;\u0026gt;\u0026#39;: if pointer + 2 \u0026gt; len(paper_tape): paper_tape.append(0) pointer += 1 elif code[position] == \u0026#39;\u0026lt;\u0026#39;: if pointer != 0: pointer -= 1 else: print(\u0026#39;Data overflow!\u0026#39;) return elif code[position] == \u0026#39;+\u0026#39;: if paper_tape[pointer] != 255: paper_tape[pointer] += 1 else: paper_tape[pointer] = 0 elif code[position] == \u0026#39;-\u0026#39;: if paper_tape[pointer] != 0: paper_tape[pointer] -= 1 else: paper_tape[pointer] = 255 elif code[position] == \u0026#39;.\u0026#39;: print(chr(paper_tape[pointer]),end=\u0026#39;\u0026#39;) elif code[position] == \u0026#39;,\u0026#39;: text = input() if len(text) == 1: paper_tape[pointer] = ord(text) else: print(\u0026#39;Invalid input!\u0026#39;) return elif code[position] == \u0026#39;[\u0026#39;: if paper_tape[pointer] == 0: position += 1 while code[position] != \u0026#39;]\u0026#39; or i != 0: if code[position] == \u0026#39;[\u0026#39;: i += 1 elif code[position] == \u0026#39;]\u0026#39;: i -= 1 if mode == \u0026#39;debug\u0026#39;: print(position,pointer,code[position],i) if position != len(code): position += 1 else: print(\u0026#39;Syntax error! (Cannot find corresponding \u0026#34;]\u0026#34;)\u0026#39;) return elif code[position] == \u0026#39;]\u0026#39;: if paper_tape[pointer] != 0: position -= 1 while code[position] != \u0026#39;[\u0026#39; or i != 0: if code[position] == \u0026#39;[\u0026#39;: i -= 1 elif code[position] == \u0026#39;]\u0026#39;: i += 1 if mode == \u0026#39;debug\u0026#39;: print(position,pointer,code[position],i) if position != 0: position -= 1 else: print(\u0026#39;Syntax error! (Cannot find corresponding \u0026#34;[\u0026#34;)\u0026#39;) return else: if strict: print(\u0026#39;Invalid code \u0026#34;\u0026#39;,code[position],\u0026#39;\u0026#34; !\u0026#39;) return if mode == \u0026#39;debug\u0026#39;: print(paper_tape,pointer,code[position],i) elif mode != \u0026#39;normal\u0026#39;: print(\u0026#39;Invalid parameter\u0026#39;) return position += 1 paper_tape_machine(input(),\u0026#39;normal\u0026#39;,False) 测试 来一段代码试一下\n++++++++++[\u0026gt;+++++++\u0026gt;++++++++++\u0026gt;+++\u0026gt;+\u0026lt;\u0026lt;\u0026lt;\u0026lt;-]\u0026gt;++.\u0026gt;+.+++++++..+++.\u0026gt;++.\u0026lt;\u0026lt;+++++++++++++++.\u0026gt;.+++.------.--------.\u0026gt;+.\u0026gt;.输出结果为\nHello World! 成功了~ \u0026lt;(￣︶￣)\u0026gt;\n临时总结 虽然用python成功实现了解释器，但代码还是不够精简，且没有经过大量的测试，有可能会出现一些问题，所以还需要继续改进\n 思维是灵魂的自我谈话 ——柏拉图\n 未完待续 (￣o￣) . z Z\u0026hellip;\u0026hellip;\n","date":"2021-01-01T00:00:00Z","image":"https://cdn.jsdelivr.net/gh/Zacrous/img/img/html.webp","permalink":"https://zacrous.top/p/brainfuck-python/","title":"BrainFuck解释器 Python 实现"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2021-01-01T00:00:00Z","permalink":"https://zacrous.top/p/math-typesetting/","title":"Math Typesetting"}]